
### GC 

#### 引用计数回收算法 (简单有效)

不再需要 ==> 没有其他对象引用到它。

引用数为0则回收。

类似 linux 文件系统的 硬链接

**无法处理循环引用** IE 6，7

计数器消耗资源

主动放弃引用，打破循环引用

Python 以引用计数为主，标记、分代为辅。

#### 标记清除算法 Mark-Sweep法 (stop the world 避免程序状态被改变)

golang 1.5 以前使用

==> 对象是否可以获得，从根对象开始定期找所有引用的对象。

2012 现代浏览器都使用此算法。

#### 三色增量标记 Mark-Sweep法改进版 并发GC算法

可以在程序执行的同时进行收集

缺点：垃圾产生速度大于收集速度时，会垃圾越来越多

golang 1.5、1.6



#### 分代收集 GC 

也是 Mark-Sweep法的改进。


弱代假说，年轻的对象通常死得快

- 小阀值 		-- 触发0代收集 
		(使用复制算法[切尼算法]，年老代使用标记清除算法[标记压缩])
- 较大阀值 	-- 触发1代
- 更大阀值 	-- 触发2代


#### 复制收集

适用于在大量对象中，只有小部分存活的情况

将存活的对象复制到另外的空间中





### tcp 三次握手过程

6 种标示位：SYN(synchronus建立联机) ACK(acknowledgement确认) PSH(push) FIN(finish) RST(reset) URG(urgent紧急)

	// seq 顺序号码，acknum 确认号码, xx和yy随机产生
	syn=1,seqA=xx. => 			(SYN_SEND)
	<= syn=1,ack=1,acknum=seqA+1,seqB=yy  (SYN_RECV)
	ack=1,acknum=seqB+1. => 	(ESTABLISHED)

### tcp 四次挥手

	FIN => (一方告知没有数据可以结束)
	<= ACK (另一方表示了解，但需要等待我准备好)
	<= FIN (另一方也可以结束了)
	ACK =>

### 操作系统 内核态 用户态

#### 硬中断 软中断

内核态拥有最高特权。用户态不能使用危险操作。
	
用户态切换到内核态（系统调用，异常，外围设备中断）

都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的


### 进程 线程 协程 协程实现方式

最初是多进程，上下文切换开销大，资源不共享，进程间通信。

后来发明多线程，进程内共享资源，上下文切换开销小。进程是线程的容器。

但一个线程挂掉，整个进程也会挂掉。

协程通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，进而突破了线程在IO上的性能瓶颈。

协程比线程要出现得早，在1963年首次提出, 但没有流行开来。


- 进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信

- 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位，共享所属进程的资源，地址空间 Linux 2.6 开始支持多线程

- 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。

主动释放 CPU，或者由调度器管理(优先级等，阻塞就绪运行)

协程切换不过就是保存寄存器+跳转到另一个函数的半中间

#### golang 协程的实现原理

goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价

goroutine是协作式调度的，如果goroutine会执行很长时间，而且不是通过等待读取或写入channel的数据来同步的话，就需要主动调用Gosched()来让出CPU


#### 进程间通信
- 管道
	
	命名管道，可无亲缘进程间通信
- 信号
- 消息队列
- 信号量
	
	信号量为0则代表资源不可访问。为1则代表允许一个线程访问。

	mutex 锁(互斥体) 相当于二值信号量。

	自旋锁 (一直循环检查是否释放锁)

- 内存共享
- 套接字
	
	同一机器进程间通信，不同机器进程间通信

	使用 protocol ip port 来唯一标识。

	1. TCP Stream Sockets 面向连接，保证数据分发，包间没有边界(粘包)

	2. UDP Datagram Sockets 无连接，不保证分发



### 进程切换

	从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
	1. 保存处理机上下文，包括程序计数器和其他寄存器。
	2. 更新PCB(进程控制块)信息。
	3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
	4. 选择另一个进程执行，并更新其PCB。
	5. 更新内存管理的数据结构。
	6. 恢复处理机上下文。





### 线程安全

	原子性，可见性，多线程操作相同资源

### 死锁

产生死锁四个必要条件

- 互斥条件 			（不可能破坏）
- 不可抢占条件		（实现困难，降低性能）
- 占有且申请条件 	（降低性能）
- 循环等待条件

银行家算法

在实际的操作系统中往往采用死锁的检测与恢复方法来排除死锁（借助外力，交警指挥）



### IO 模式


- 阻塞 I/O（blocking IO）
- 非阻塞 I/O（nonblocking IO）
- I/O 多路复用（ IO multiplexing）
- 信号驱动 I/O（ signal driven IO）
- 异步 I/O（asynchronous IO）


BIO / NIO / AIO /
blocking IO的特点就是在IO执行的两个阶段都被block了。

nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。

I/O 多路复用 或叫 事件驱动IO（ IO multiplexing）(select, poll, epoll)
和阻塞IO 类似，甚至更差，但可以同时处理多个 IO

异步 I/O
完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了

linux 三方开发了 libeio 使用 阻塞 IO 和 线程池 模拟 异步 IO 

(nodejs，它用的libuv库封装了linux下的libeio和libev，libev提供事件驱动，而libeio则提供异步IO，作者都是Marc Lehmann。)

libuv 为实现跨平台方案，将 IO 分为两类：网络IO 和 disk IO。

网络IO 使用 epoll / kqueue / events ports / IOCP

disk IO 使用 Thread Pool (各操作系统支持好)

### 同步异步阻塞非阻塞

同步异步 即 用户进程 等或不等 IO 结果

阻塞 非阻塞 即 线程是否挂起（不占用CPU）	

### select poll epoll IO多路复用 (几种轮询技术,实际仍然是阻塞同步)

本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的

就绪态 运行态 阻塞态

#### select	对多路同步I/O进行轮询

（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大

（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大

（3）select支持的文件描述符数量太小了，默认是1024，可以改

#### poll(没有最大描述符限制)	I/O多路转换，同样是轮询

数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作

#### epoll (select/poll 增强版，基于 callback)

- 没有最大文件描述符限制
- 不使用轮询，活跃的fd调 callback,跟总fd无关
- mmap 内存映射，内核和用户空间共享一块内存


**epoll 在 fd 剧增时，不会出现 select/poll 的线性性能下降**

epoll 适用于 连接数多 空闲连接多, fd 越多, epoll 优势越大


### 分页内存管理 内存映射

#### 页面置换算法

- FIFO 先进先出
- OPT(MIN)算法

选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。

可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。

- LRU(Least-Recently-Used)算法

用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。

LRU准确实现：计数器法，页码栈法。

由于代价较高，通常不使用准确实现，而是采用近似实现，例如Clock算法。

- 时钟（Clock）页面置换算法

页表循环链表，指针指向最老页，若标记为0，则换出到硬盘

若标记为1，则标记置0，指针下移。


内存抖动现象：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的。

Belady现象：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。

FIFO会产生Belady异常。

栈式算法无Belady异常，LRU，LFU（最不经常使用），OPT都属于栈式算法。


## 实现守护进程(linux 服务: httpd, crond, mysqld)

守护进程脱离 shell 终端。不被终端打断，不在终端显示执行过程的信息。

启动它的父进程的运行环境隔离开来

- 创建子进程，父进程退出

	子进程变为孤儿进程，由 init 进程作为父进程收养。

- 子进程创建新的会话

	子进程便复制了原父进程的进程控制块（PCB），
	相应地继承了一些信息，包括会话、进程组、控制终端等信息

	需要调用 setsid 函数使子进程完全摆脱父进程的环境

	**进程组**：
	**会话**：

- 改变当前目录为根目录

	调用 chdir 函数切换到根目录
	原因：进程运行过程中，当前目录所在的文件系统是不能卸载的。

- 重设文件权限掩码

	子进程继承父进程的文件操作权限，umask 设置文件权限掩码。

- 关闭文件描述符

	由于守护进程脱离了终端运行，因此标准输入、标准输出、标准错误输出这3个文件描述符也要关闭

### 守护进程日志实现

	调用 openlog syslog closelog 等函数，
	linux 守护进程 **syslogd** 负责接收日志



# 七周七并发

并行计算和分布式计算

## 多处理器并行

- 共享内存多处理器系统(单机)
- 分布式内存的多处理器系统(多机，突破单机瓶颈/容错)

## 七个模型

### 线程与锁

很多不足，**但它是其他模型的技术基础**

### 函数式编程

抛弃可变状态

没有可变状态，不使用锁就可以安全的访问

不会由共享可变状态带来的种种问题

**函数为第一等公民** 可以赋值给其他变量，作为参数/返回值等。

没有副作用，不修改外部变量

**引用透明**(函数的调用仅依赖参数，不依赖外部状态) 

柯里化 -> 将多个参数的函数转换为单个参数的函数

因为不要求顺序，可以惰性求值和并性处理

函子 加强函子 单子


### Clojure 之道-分离标识与状态

函数式编程不支持可变量。

"持久数据" 即分离标志和状态

事务 -> 日志，锁机制


### Actor (更加面向对象)
	
使用 Actor 保留可变状态，只是不进行共享

消息和信箱

任其崩溃

分布式


### 通信顺序进程
	
CSP 与 actor 模型很相似，两者都基于消息传递。
不过 CSP 侧重传递的通道，actor 侧重两端的实体。

channel 为第一类对象，它是一个线程安全的队列

默认 channel 是同步的(无缓存)

### 数据级并行

GPU 综合使用流水线、多ALU等技术。

OpenCL 可对不同架构的 GPU 抽象的编程

OpenCL 还适用于 CPU

数据并行编程，并不适用于所有问题领域，主要适用数值领域

### 大数据系统 Lambda 架构 (实时大数据处理框架)


## 数据结构



### 树 数据库 索引实现方式 B-tree （磁盘 IO 次数，利用预读，一整页）

- 哈弗曼树(最优二叉树) ：

比如传输数据中包含 5 中字母 abcde。

用于不等长编码，用路径表示编码，频率越高的对象，放在路径越小的地方。

比如左分支为0，右分支为1. 对应字母用根节点到叶子的路径表示编码

- 平衡二叉树(对二叉排序树改进)

保持平衡，防止效率变低。

- B树(数据库索引) 平衡树

如果要发挥磁盘的全部特性，软件需要满足的技术特点：一次读取或写入固定大小的一块数据，并尽可能减少随机查找这个操作的次数（因为随机查找意味着随机寻道）

一次读写固定大小一整块数据，数组？

一种是数组满了就复制到新数组

另一种是数组大小不变，但增加数组个数 -- B 树的核心思路

查找定位数据IO 操作相对较少

1. 树高低  2. 数组 每个node都是一个数组

B 树节点有x个关键字，则其子节点有 x+1 个。

	#define m 1024
	struct BTNode;
	typedef struct BTNode *PBTNode;
	typedef struct BTNode *BTree;
	typedef struct BTNode *PBTree;
	struct BTNode {
		int keyNum; 		// 实际关键字个数，keyNum<m
		PBTNode parent; 	// 指向父节点
		PBTNode *ptr; 		// 子树指针向量 ：ptr[0]...ptr[keyNum]
		KeyType *key; 		// 关键字向量：key[0]...key[keyNum-1]
	}

- B+树

**所有的叶子节点包含所有的关键字信息。**

其他非叶子节点，仅含子树最大或最小关键字。可看做索引。


- R 树 (把B树扩展到了多维空间)

用矩形范围表示索引。




- 红黑树 R-B Tree

2-3-4树，(有2,3,4个子女的 B 树)

二叉查找树的基础上增加着色，使其保持相对平衡。时间复杂度最坏为 logn

1. 每个结点要么是红的要么是黑的。  

2. 根结点是黑的。  

3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  

4. 如果一个结点是红的，那么它的两个儿子都是黑的。  

5. 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑节点 

左旋 右旋




## TODO 

## 加强
- 数据结构 (树)
- IO 多路复用 (select poll epoll)

## openstack docker

## 其他计算机基础

## 加强 Python

## hashMap

	key 的 hash 值得到数组的下标。存放到数组元素指向的链表中。

